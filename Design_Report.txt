Design Report(Group 14)

Intro:

- For our project 3 we implemented a B+ tree index to further the Buffer Manager program. Our B+ tree uses a search key of type integer to traverse the tree to find 
coresposning record id pairs. This allows us to effiecently travers the database, since it is self balancing, in O(log n) for search, insert, and delete. 

Traversing the B+ tree:

-

Design Choices:

-

Unpin Page:

- We decided to unpin the pages as soon as possible. This allows us to keep the buffer pool from filling up. 

Efficiency:

	Search: searching the tree will result in a I/O cost of 2*height, since we need to read in and write out through the pages.
	
	Insert: Inserting will be a simple cost of 2, since we are writing directly to the root node of the tree. 
	
	Scanning: Scanning the tree will have a worst case scenario of O(log n) if we need to read every leaf node, or the same as Search. 
	
	Splitting: Splitting results in a I/O cost of 4. This is due to the need of reading in and writing both the currernt node and the new node we are creaitng in the split.


Extra Tests:

- We wrote the following tests cases to further check our program for errors.

-Test #
	- Description
-Test #
	- Description 
